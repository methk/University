"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var RadixUniverseConfig_1 = tslib_1.__importDefault(require("./RadixUniverseConfig"));
var RadixNodeDiscoveryFromNodeFinder_1 = tslib_1.__importDefault(require("./RadixNodeDiscoveryFromNodeFinder"));
var RadixNodeDiscoveryFromSeed_1 = tslib_1.__importDefault(require("./RadixNodeDiscoveryFromSeed"));
var RadixNodeConnection_1 = tslib_1.__importDefault(require("./RadixNodeConnection"));
var RadixUtil_1 = tslib_1.__importDefault(require("../common/RadixUtil"));
var RadixTokenManager_1 = require("../token/RadixTokenManager");
var RadixLogger_1 = require("../common/RadixLogger");
var long_1 = tslib_1.__importDefault(require("long"));
var promise_retry_1 = tslib_1.__importDefault(require("promise-retry"));
var ipaddr_js_1 = tslib_1.__importDefault(require("ipaddr.js"));
var RadixUniverse = /** @class */ (function () {
    function RadixUniverse() {
        var _this = this;
        this.initialized = false;
        this.liveNodes = [];
        this.connectedNodes = [];
        this.lastNetworkUpdate = 0;
        this.networkUpdateInterval = 1000 * 60 * 10;
        /**
         * Close all open connections
         * Recommended to call this before quitting the application, so that nodes can close the corresponding open connections as well
         */
        this.closeAllConnections = function () {
            var e_1, _a;
            try {
                for (var _b = tslib_1.__values(_this.connectedNodes), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var connection = _c.value;
                    connection.close();
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
    }
    /**
     * Bootstraps the universe with a specific configuration
     * Must be called before performing any operations
     * Use one of the predefined static configurations in this class
     * @param config
     */
    RadixUniverse.prototype.bootstrap = function (config) {
        this.universeConfig = config.universeConfig;
        this.nodeDiscovery = config.nodeDiscovery;
        this.nodeRPCAddress = config.nodeRPCAddress;
        this.initialized = true;
        RadixTokenManager_1.radixTokenManager.initialize();
    };
    /**
     * Given an IP address this function resolves a deterministic
     * DNS record in the radixnode.net domain.
     *
     * @param address IP address or hostname
     */
    RadixUniverse.resolveNodeName = function (address) {
        try {
            var ipbytes = ipaddr_js_1.default.parse(address).toByteArray();
            if (ipbytes.length == 4) { // IPv4
                // trivial but safe left-shift function that does not overflow
                var shl = function (base, exp) { return base * Math.pow(2, exp); };
                // use + instead of | (bitwise or) because it overflows
                var ip = ipbytes[3] + shl(ipbytes[2], 8) + shl(ipbytes[1], 16) + shl(ipbytes[0], 24);
                return "a" + ip.toString(36) + ".radixnode.net";
            }
            RadixLogger_1.logger.warn('No base36 encoder for IPv6 yet');
            return "[" + address + "]";
        }
        catch (err) {
            // the address has neither IPv6 nor IPv4 format => hostname
        }
        return address;
    };
    /**
     * Gets the universe magic byte, used mainly for generating an address from a public key
     * @returns
     */
    RadixUniverse.prototype.getMagicByte = function () {
        return this.universeConfig.getMagicByte();
    };
    RadixUniverse.prototype.loadPeersFromBootstrap = function () {
        var _this = this;
        return promise_retry_1.default(function (retry, attempt) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var _a, error_1;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 2, , 3]);
                        _a = this;
                        return [4 /*yield*/, this.nodeDiscovery.loadNodes()];
                    case 1:
                        _a.liveNodes = _b.sent();
                        this.lastNetworkUpdate = Date.now();
                        return [2 /*return*/, this.liveNodes];
                    case 2:
                        error_1 = _b.sent();
                        RadixLogger_1.logger.error(error_1);
                        retry();
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        }); }, {
            retries: 1000,
            maxtimeout: 60000
        });
    };
    /**
     * Gets a RadixNodeConnection for a specified shard
     * Updates the node list if neccessary
     * @param shard
     * @returns node connection
     */
    RadixUniverse.prototype.getNodeConnection = function (shard) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var e_2, _a, e_3, _b;
            try {
                // Find active connection, return
                for (var _c = tslib_1.__values(_this.connectedNodes), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var node = _d.value;
                    if (node.isReady() && _this.canNodeServiceShard(node.node, shard)) {
                        RadixLogger_1.logger.info('Got an active connection');
                        return resolve(node);
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_2) throw e_2.error; }
            }
            var _loop_1 = function (node) {
                if (_this.canNodeServiceShard(node.node, shard)) {
                    RadixLogger_1.logger.info('Got a pending connection');
                    // Wait for ready or error
                    node.on('open', function () {
                        resolve(node);
                    });
                    node.on('closed', function () {
                        resolve(_this.getNodeConnection(shard));
                    });
                    return { value: void 0 };
                }
            };
            try {
                // Failing that, find a pending node connection
                for (var _e = tslib_1.__values(_this.connectedNodes), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var node = _f.value;
                    var state_1 = _loop_1(node);
                    if (typeof state_1 === "object")
                        return state_1.value;
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                }
                finally { if (e_3) throw e_3.error; }
            }
            // Open a new connection, return when ready
            RadixLogger_1.logger.info('Opening a new connection');
            _this.openNodeConnection(shard).then(function (connection) {
                if (connection) {
                    resolve(connection);
                }
                else {
                    reject("Coudln't find a node to connect to");
                }
            });
        });
    };
    RadixUniverse.prototype.openNodeConnection = function (shard) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _loop_2, this_1, _a, _b, node, state_2, e_4_1;
            var e_4, _c;
            var _this = this;
            return tslib_1.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        if (!(Date.now() - this.lastNetworkUpdate > this.networkUpdateInterval)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.loadPeersFromBootstrap()];
                    case 1:
                        _d.sent();
                        _d.label = 2;
                    case 2:
                        // Randomize node order every time
                        this.liveNodes = RadixUtil_1.default.shuffleArray(this.liveNodes);
                        _loop_2 = function (node) {
                            var connection_1, error_2;
                            return tslib_1.__generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        if (!this_1.canNodeServiceShard(node, shard)) return [3 /*break*/, 5];
                                        connection_1 = new RadixNodeConnection_1.default(node, this_1.nodeRPCAddress);
                                        this_1.connectedNodes.push(connection_1);
                                        connection_1.on('closed', function () {
                                            // Remove connection from connected nodes 
                                            var nodeIndex = _this.connectedNodes.indexOf(connection_1);
                                            if (nodeIndex > -1) {
                                                _this.connectedNodes.splice(nodeIndex, 1);
                                            }
                                        });
                                        _a.label = 1;
                                    case 1:
                                        _a.trys.push([1, 3, , 4]);
                                        return [4 /*yield*/, connection_1.openConnection()];
                                    case 2:
                                        _a.sent();
                                        return [3 /*break*/, 4];
                                    case 3:
                                        error_2 = _a.sent();
                                        RadixLogger_1.logger.error(error_2);
                                        return [2 /*return*/, { value: null }];
                                    case 4: return [2 /*return*/, { value: connection_1 }];
                                    case 5: return [2 /*return*/];
                                }
                            });
                        };
                        this_1 = this;
                        _d.label = 3;
                    case 3:
                        _d.trys.push([3, 8, 9, 10]);
                        _a = tslib_1.__values(this.liveNodes), _b = _a.next();
                        _d.label = 4;
                    case 4:
                        if (!!_b.done) return [3 /*break*/, 7];
                        node = _b.value;
                        return [5 /*yield**/, _loop_2(node)];
                    case 5:
                        state_2 = _d.sent();
                        if (typeof state_2 === "object")
                            return [2 /*return*/, state_2.value];
                        _d.label = 6;
                    case 6:
                        _b = _a.next();
                        return [3 /*break*/, 4];
                    case 7: return [3 /*break*/, 10];
                    case 8:
                        e_4_1 = _d.sent();
                        e_4 = { error: e_4_1 };
                        return [3 /*break*/, 10];
                    case 9:
                        try {
                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                        }
                        finally { if (e_4) throw e_4.error; }
                        return [7 /*endfinally*/];
                    case 10: return [2 /*return*/, null];
                }
            });
        });
    };
    RadixUniverse.prototype.canNodeServiceShard = function (node, shard) {
        if (node.system) {
            var low = long_1.default.fromValue(node.system.shards.low);
            var high = long_1.default.fromValue(node.system.shards.high);
            if (high.lessThan(low)) {
                // Wrap around
                return (shard.greaterThanOrEqual(low) || shard.lessThanOrEqual(high));
            }
            else {
                return (shard.greaterThanOrEqual(low) && shard.lessThanOrEqual(high));
            }
        }
        return false;
    };
    RadixUniverse.ALPHANET = {
        universeConfig: RadixUniverseConfig_1.default.ALPHANET,
        nodeDiscovery: new RadixNodeDiscoveryFromNodeFinder_1.default('https://alphanet.radixdlt.com/node-finder', function (nodeIp) { return "https://alphanet.radixdlt.com/node/" + nodeIp + "/rpc"; }),
        nodeRPCAddress: function (nodeIp) { return "wss://alphanet.radixdlt.com/node/" + nodeIp + "/rpc"; },
    };
    RadixUniverse.ALPHANET2 = {
        universeConfig: RadixUniverseConfig_1.default.ALPHANET2,
        nodeDiscovery: new RadixNodeDiscoveryFromNodeFinder_1.default('https://alphanet2.radixdlt.com/node-finder', function (nodeIp) { return "https://" + RadixUniverse.resolveNodeName(nodeIp) + "/rpc"; }),
        nodeRPCAddress: function (nodeIp) { return "wss://" + RadixUniverse.resolveNodeName(nodeIp) + "/rpc"; },
    };
    RadixUniverse.HIGHGARDEN = {
        universeConfig: RadixUniverseConfig_1.default.HIGHGARDEN,
        nodeDiscovery: new RadixNodeDiscoveryFromNodeFinder_1.default('https://highgarden.radixdlt.com/node-finder', function (nodeIp) { return "https://highgarden.radixdlt.com/node/" + nodeIp + "/rpc"; }),
        nodeRPCAddress: function (nodeIp) { return "wss://highgarden.radixdlt.com/node/" + nodeIp + "/rpc"; },
    };
    RadixUniverse.SUNSTONE = {
        universeConfig: RadixUniverseConfig_1.default.SUNSTONE,
        nodeDiscovery: new RadixNodeDiscoveryFromNodeFinder_1.default('https://sunstone.radixdlt.com/node-finder', function (nodeIp) { return "https://" + nodeIp + "/rpc"; }),
        nodeRPCAddress: function (nodeIp) { return "wss://" + nodeIp + ":443/rpc"; },
    };
    RadixUniverse.WINTERFELL = {
        universeConfig: RadixUniverseConfig_1.default.WINTERFELL,
        nodeDiscovery: new RadixNodeDiscoveryFromSeed_1.default('http://52.190.0.18:8080/rpc'),
        nodeRPCAddress: function (nodeIp) { return "ws://" + nodeIp + ":8080/rpc"; },
    };
    RadixUniverse.WINTERFELL_LOCAL = {
        universeConfig: RadixUniverseConfig_1.default.WINTERFELL_LOCAL,
        nodeDiscovery: new RadixNodeDiscoveryFromSeed_1.default('http://localhost:8080/rpc'),
        nodeRPCAddress: function (nodeIp) { return "ws://127.0.0.1:8080/rpc"; },
    };
    return RadixUniverse;
}());
exports.default = RadixUniverse;
exports.radixUniverse = new RadixUniverse();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmFkaXhVbml2ZXJzZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9tb2R1bGVzL3VuaXZlcnNlL1JhZGl4VW5pdmVyc2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsc0ZBQXVEO0FBRXZELGdIQUFpRjtBQUNqRixvR0FBcUU7QUFFckUsc0ZBQXVEO0FBQ3ZELDBFQUEyQztBQUczQyxnRUFBOEQ7QUFDOUQscURBQThDO0FBRTlDLHNEQUF1QjtBQUN2Qix3RUFBd0M7QUFDeEMsZ0VBQStCO0FBRS9CO0lBQUE7UUFBQSxpQkEyT0M7UUEvTFUsZ0JBQVcsR0FBRyxLQUFLLENBQUE7UUFLbEIsY0FBUyxHQUFnQixFQUFFLENBQUE7UUFDM0IsbUJBQWMsR0FBMEIsRUFBRSxDQUFBO1FBQzFDLHNCQUFpQixHQUFHLENBQUMsQ0FBQTtRQUNyQiwwQkFBcUIsR0FBRyxJQUFJLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQTtRQTBKOUM7OztXQUdHO1FBQ0ksd0JBQW1CLEdBQUc7OztnQkFDekIsS0FBeUIsSUFBQSxLQUFBLGlCQUFBLEtBQUksQ0FBQyxjQUFjLENBQUEsZ0JBQUEsNEJBQUU7b0JBQXpDLElBQU0sVUFBVSxXQUFBO29CQUNqQixVQUFVLENBQUMsS0FBSyxFQUFFLENBQUE7aUJBQ3JCOzs7Ozs7Ozs7UUFDTCxDQUFDLENBQUE7SUFxQkwsQ0FBQztJQXJMRzs7Ozs7T0FLRztJQUNJLGlDQUFTLEdBQWhCLFVBQWlCLE1BSWhCO1FBQ0csSUFBSSxDQUFDLGNBQWMsR0FBRyxNQUFNLENBQUMsY0FBYyxDQUFBO1FBQzNDLElBQUksQ0FBQyxhQUFhLEdBQUcsTUFBTSxDQUFDLGFBQWEsQ0FBQTtRQUN6QyxJQUFJLENBQUMsY0FBYyxHQUFHLE1BQU0sQ0FBQyxjQUFjLENBQUE7UUFDM0MsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUE7UUFFdkIscUNBQWlCLENBQUMsVUFBVSxFQUFFLENBQUE7SUFDbEMs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