import { BehaviorSubject, Subject } from 'rxjs/Rx';
import { Client } from 'rpc-websockets';
import { RadixEUID, RadixSerializer } from '../RadixAtomModel';
import { logger } from '../common/RadixLogger';
import events from 'events';
export class RadixNodeConnection extends events.EventEmitter {
    constructor(node, nodeRPCAddress) {
        super();
        this.node = node;
        this.nodeRPCAddress = nodeRPCAddress;
        this._subscriptions = {};
        this._atomUpdateSubjects = {};
        this.lastSubscriberId = 1;
        this.ping = () => {
            if (this.isReady()) {
                this._socket
                    .call('Network.getSelf', { id: 0 }).then((response) => {
                    logger.debug(`Ping`, response);
                });
            }
        };
        this.close = () => {
            this._socket.close();
        };
        this._onClosed = () => {
            logger.info('Socket closed');
            if (this.pingInterval) {
                clearInterval(this.pingInterval);
            }
            // Close subject
            for (const subscriberId in this._subscriptions) {
                const subscription = this._subscriptions[subscriberId];
                if (!subscription.closed) {
                    subscription.error('Socket closed');
                }
            }
            for (const subscriberId in this._atomUpdateSubjects) {
                const subject = this._atomUpdateSubjects[subscriberId];
                if (!subject.closed) {
                    subject.error('Socket closed');
                }
            }
            this.emit('closed');
        };
        this._onAtomSubmissionStateUpdate = (notification) => {
            logger.info('Atom Submission state update', notification);
            // Handle atom state update
            const subscriberId = notification.subscriberId;
            const value = notification.value;
            const message = notification.message;
            const subject = this._atomUpdateSubjects[subscriberId];
            switch (value) {
                case 'SUBMITTING':
                case 'SUBMITTED':
                    subject.next(value);
                    break;
                case 'STORED':
                    subject.next(value);
                    subject.complete();
                    break;
                case 'COLLISION':
                case 'ILLEGAL_STATE':
                case 'UNSUITABLE_PEER':
                case 'VALIDATION_ERROR':
                    subject.error(value + ': ' + message);
                    break;
            }
        };
        this._onAtomReceivedNotification = (notification) => {
            logger.info('Atom received', notification);
            // Store atom for testing
            // let jsonPath = './atomNotification.json'
            // // let jsonPath = path.join(__dirname, '..', '..', '..', '..', 'atomNotification.json')
            // logger.info(jsonPath)
            // fs.writeFile(jsonPath, JSON.stringify(notification), (error) => {
            //    // Throws an error, you could also catch it here
            //    if (error) { throw error }
            //    // Success case, the file was saved
            //    logger.info('Atom saved!')
            // })
            const deserializedAtoms = RadixSerializer.fromJson(notification.atoms);
            logger.info(deserializedAtoms);
            // Check HIDs for testing
            for (let i = 0; i < deserializedAtoms.length; i++) {
                const deserializedAtom = deserializedAtoms[i];
                const serializedAtom = notification.atoms[i];
                if (serializedAtom.hid &&
                    deserializedAtom.hid.equals(RadixEUID.fromJson(serializedAtom.hid))) {
                    logger.info('HID match');
                }
                else if (serializedAtom.hid) {
                    logger.error('HID mismatch');
                }
            }
            // Forward atoms to correct wallets
            const subscription = this._subscriptions[notification.subscriberId];
            for (const atom of deserializedAtoms) {
                subscription.next({
                    action: 'STORE',
                    atom,
                });
            }
        };
        this.node = node;
    }
    getSubscriberId() {
        this.lastSubscriberId++;
        return this.lastSubscriberId;
    }
    /**
     * Check whether the node connection is ready for requests
     * @returns true if ready
     */
    isReady() {
        return this._socket && this._socket.ready;
    }
    /**
     * Opens connection
     * @returns a promise that resolves once the connection is ready, or rejects on error or timeout
     */
    async openConnection() {
        return new Promise((resolve, reject) => {
            this.address = this.nodeRPCAddress(this.node.host.ip);
            // For testing atom queueing during connection issues
            // if (Math.random() > 0.1) {
            //    this.address += 'garbage'
            // }
            logger.info(`Connecting to ${this.address}`);
            this._socket = new Client(this.address, {
                reconnect: false
            });
            this._socket.on('close', this._onClosed);
            this._socket.on('error', error => {
                logger.error(error);
                reject(error);
            });
            setTimeout(() => {
                if (!this._socket.ready) {
                    logger.debug('Socket timeout');
                    this._socket.close();
                    this.emit('closed');
                    reject('Timeout');
                }
            }, 5000);
            this._socket.on('open', () => {
                // this.pingInterval = setInterval(this.ping, 10000)
                this.emit('open');
                this._socket.on('Atoms.subscribeUpdate', this._onAtomReceivedNotification);
                this._socket.on('AtomSubmissionState.onNext', this._onAtomSubmissionStateUpdate);
                resolve();
            });
        });
    }
    /**
     * Subscribe for all existing and future atoms for a given address
     * @param address base58 formatted address
     * @returns a stream of atoms
     */
    subscribe(address) {
        const subscriberId = this.getSubscriberId();
        const subscription = new Subject();
        this._subscriptions[subscriberId] = subscription;
        this._socket
            .call('Atoms.subscribe', {
            subscriberId,
            query: {
                destinationAddress: address,
            },
        })
            .then((response) => {
            logger.info(`Subscribed for address ${address}`, response);
        })
            .catch((error) => {
            logger.error(error);
            subscription.error(error);
        });
        return subscription;
    }
    /**
     * Submit an atom to the ledger
     * @param atom
     * @returns A stream of the status of the atom submission
     */
    submitAtom(atom) {
        // Store atom for testing
        // let jsonPath = path.join('./submitAtom.json')
        // logger.info(jsonPath)
        // fs.writeFile(jsonPath, JSON.stringify(atom.toJson()), (error) => {
        //    // Throws an error, you could also catch it here
        //    if (error) { throw error }
        //    // Success case, the file was saved
        //    logger.info('Atom saved!')
        // })
        const subscriberId = this.getSubscriberId();
        const atomStateSubject = new BehaviorSubject('CREATED');
        this._atomUpdateSubjects[subscriberId] = atomStateSubject;
        const timeout = setTimeout(() => {
            this._socket.close();
            atomStateSubject.error('Socket timeout');
        }, 5000);
        this._socket
            .call('Universe.submitAtomAndSubscribe', {
            subscriberId,
            atom: atom.toJson()
        })
            .then(() => {
            clearTimeout(timeout);
            atomStateSubject.next('SUBMITTED');
        })
            .catch((error) => {
            clearTimeout(timeout);
            atomStateSubject.error(error);
        });
        return atomStateSubject;
    }
    /**
     * NOT IMPLEMENTED
     * Query the ledger for an atom by its id
     * @param id
     * @returns The atom
     */
    async getAtomById(id) {
        // TODO: everything
        return this._socket
            .call('Atoms.getAtomInfo', { id: id.toJson() })
            .then((response) => {
            return RadixSerializer.fromJson(response.result);
        });
    }
}
export default RadixNodeConnection;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmFkaXhOb2RlQ29ubmVjdGlvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9tb2R1bGVzL3VuaXZlcnNlL1JhZGl4Tm9kZUNvbm5lY3Rpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLGVBQWUsRUFBRSxPQUFPLEVBQUUsTUFBTSxTQUFTLENBQUE7QUFDbEQsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLGdCQUFnQixDQUFBO0FBSXZDLE9BQU8sRUFBYSxTQUFTLEVBQUUsZUFBZSxFQUFtQixNQUFNLG1CQUFtQixDQUFBO0FBQzFGLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQTtBQUU5QyxPQUFPLE1BQU0sTUFBTSxRQUFRLENBQUE7QUFvQjNCLE1BQU0sT0FBTyxtQkFBb0IsU0FBUSxNQUFNLENBQUMsWUFBWTtJQWV4RCxZQUFxQixJQUFlLEVBQVcsY0FBMEM7UUFDckYsS0FBSyxFQUFFLENBQUE7UUFEVSxTQUFJLEdBQUosSUFBSSxDQUFXO1FBQVcsbUJBQWMsR0FBZCxjQUFjLENBQTRCO1FBWmpGLG1CQUFjLEdBRWxCLEVBQUUsQ0FBQTtRQUVFLHdCQUFtQixHQUV2QixFQUFFLENBQUE7UUFFRSxxQkFBZ0IsR0FBRyxDQUFDLENBQUE7UUFzQnBCLFNBQUksR0FBRyxHQUFHLEVBQUU7WUFDaEIsSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFLEVBQUU7Z0JBQ2hCLElBQUksQ0FBQyxPQUFPO3FCQUNYLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLFFBQWEsRUFBRSxFQUFFO29CQUN2RCxNQUFNLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxRQUFRLENBQUMsQ0FBQTtnQkFDbEMsQ0FBQyxDQUFDLENBQUE7YUFDTDtRQUNMLENBQUMsQ0FBQTtRQWdKTSxVQUFLLEdBQUcsR0FBRyxFQUFF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