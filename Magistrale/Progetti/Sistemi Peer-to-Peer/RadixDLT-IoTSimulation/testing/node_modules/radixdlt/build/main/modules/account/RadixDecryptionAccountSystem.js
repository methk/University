"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var RadixECIES_1 = tslib_1.__importDefault(require("../crypto/RadixECIES"));
var RadixLogger_1 = require("../common/RadixLogger");
var RadixDecryptionAccountSystem = /** @class */ (function () {
    function RadixDecryptionAccountSystem(decryptionProvider) {
        this.name = 'DECRYPTION';
        if (decryptionProvider) {
            this.decryptionProvider = decryptionProvider;
        }
    }
    RadixDecryptionAccountSystem.prototype.processAtomUpdate = function (atomUpdate) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var atom, privateKey, _a, _b, protector, error_1, e_1_1, rawPayload, error_2;
            var e_1, _c;
            return tslib_1.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        atom = atomUpdate.atom;
                        if (!(this.decryptionProvider &&
                            atom.hasOwnProperty('encryptor') &&
                            atom.hasOwnProperty('encrypted'))) return [3 /*break*/, 17];
                        privateKey = null;
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 8, 9, 10]);
                        _a = tslib_1.__values(atom.encryptor
                            .protectors), _b = _a.next();
                        _d.label = 2;
                    case 2:
                        if (!!_b.done) return [3 /*break*/, 7];
                        protector = _b.value;
                        _d.label = 3;
                    case 3:
                        _d.trys.push([3, 5, , 6]);
                        return [4 /*yield*/, this.decryptionProvider.decryptECIESPayload(protector.data)];
                    case 4:
                        privateKey = _d.sent();
                        return [3 /*break*/, 6];
                    case 5:
                        error_1 = _d.sent();
                        return [3 /*break*/, 6];
                    case 6:
                        _b = _a.next();
                        return [3 /*break*/, 2];
                    case 7: return [3 /*break*/, 10];
                    case 8:
                        e_1_1 = _d.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 10];
                    case 9:
                        try {
                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                        }
                        finally { if (e_1) throw e_1.error; }
                        return [7 /*endfinally*/];
                    case 10:
                        if (!privateKey) return [3 /*break*/, 15];
                        _d.label = 11;
                    case 11:
                        _d.trys.push([11, 13, , 14]);
                        return [4 /*yield*/, RadixECIES_1.default.decrypt(privateKey, atom.encrypted.data)];
                    case 12:
                        rawPayload = _d.sent();
                        atom.payload = rawPayload.toString();
                        return [3 /*break*/, 14];
                    case 13:
                        error_2 = _d.sent();
                        RadixLogger_1.logger.error('Decrypted a protector but unable to decrypt payload', atom);
                        return [3 /*break*/, 14];
                    case 14: return [3 /*break*/, 16];
                    case 15:
                        RadixLogger_1.logger.trace('Unable to decrypt any protectors', atom);
                        _d.label = 16;
                    case 16: return [3 /*break*/, 18];
                    case 17:
                        if (atom.hasOwnProperty('encrypted') &&
                            !atom.hasOwnProperty('encryptor')) {
                            atom.payload = atom.encrypted.data.toString();
                        }
                        _d.label = 18;
                    case 18: return [2 /*return*/];
                }
            });
        });
    };
    return RadixDecryptionAccountSystem;
}());
exports.default = RadixDecryptionAccountSystem;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmFkaXhEZWNyeXB0aW9uQWNjb3VudFN5c3RlbS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9tb2R1bGVzL2FjY291bnQvUmFkaXhEZWNyeXB0aW9uQWNjb3VudFN5c3RlbS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFFQSw0RUFBNkM7QUFHN0MscURBQThDO0FBRTlDO0lBSUksc0NBQVksa0JBQTRDO1FBSGpELFNBQUksR0FBRyxZQUFZLENBQUE7UUFJdEIsSUFBSSxrQkFBa0IsRUFBRTtZQUNwQixJQUFJLENBQUMsa0JBQWtCLEdBQUcsa0JBQWtCLENBQUE7U0FDL0M7SUFDTCxDQUFDO0lBRVksd0RBQWlCLEdBQTlCLFVBQStCLFVBQTJCOzs7Ozs7O3dCQUNoRCxJQUFJLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQTs2QkFHeEIsQ0FBQSxJQUFJLENBQUMsa0JBQWtCOzRCQUN2QixJQUFJLENBQUMsY0FBYyxDQUFDLFdBQVcsQ0FBQzs0QkFDaEMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxXQUFXLENBQUMsQ0FBQSxFQUZoQyx5QkFFZ0M7d0JBRTVCLFVBQVUsR0FBRyxJQUFJLENBQUE7Ozs7d0JBRUcsS0FBQSxpQkFBQyxJQUF5QixDQUFDLFNBQVM7NkJBQ3ZELFVBQVUsQ0FBQTs7Ozt3QkFESixTQUFTOzs7O3dCQUdDLHFCQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxtQkFBbUIsQ0FDMUQsU0FBUyxDQUFDLElBQUksQ0FDakIsRUFBQTs7d0JBRkQsVUFBVSxHQUFHLFNBRVosQ0FBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NkJBTUwsVUFBVSxFQUFWLHlCQUFVOzs7O3dCQUVhLHFCQUFNLG9CQUFVLENBQUMsT0FBTyxDQUN2QyxVQUFVLEVBQ1QsSUFBeUIsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUM1QyxFQUFBOzt3QkFISyxVQUFVLEdBQUcsU0FHbEI7d0JBQ0QsSUFBSSxDQUFDLE9BQU8sR0FBRyxVQUFVLENBQUMsUUFBUSxFQUFFLENBQUE7Ozs7d0JBRXBDLG9CQUFNLENBQUMsS0FBSyxDQUFDLHFEQUFxRCxFQUFFLElBQUksQ0FBQyxDQUFBOzs7O3dCQUc3RSxvQkFBTSxDQUFDLEtBQUssQ0FBQyxrQ0FBa0MsRUFBRSxJQUFJLENBQUMsQ0FBQTs7Ozt3QkFFdkQsSUFDSCxJQUFJLENBQUMsY0FBYyxDQUFDLFdBQVcsQ0FBQzs0QkFDaEMsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLFdBQVcsQ0FBQyxFQUNuQzs0QkFDRSxJQUFJLENBQUMsT0FBTyxHQUFJLElBQXlCLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQTt5QkFDdEU7Ozs7OztLQUNKO0lBQ0wsbUNBQUM7QUFBRCxDQUFDLEFBbkRELElBbURDIn0=