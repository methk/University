import BufferReader from 'buffer-reader';
import EC from 'elliptic';
import crypto from 'crypto';
const ec = new EC.ec('secp256k1');
export default class RadixECIES {
    static decrypt(privKey, encrypted) {
        let reader = new BufferReader(encrypted);
        const iv = reader.nextBuffer(16);
        const ephemPubKeyEncoded = reader.nextBuffer(reader.nextUInt8());
        const ciphertext = reader.nextBuffer(reader.nextUInt32BE());
        const MAC = reader.nextBuffer(32);
        const ephemPubKey = ec.keyFromPublic(ephemPubKeyEncoded).getPublic();
        const px = ec.keyFromPrivate(privKey).derive(ephemPubKey);
        // Double hash to prevent length extension attacks
        const hash = crypto
            .createHash('sha512')
            .update(crypto
            .createHash('sha512')
            .update(px.toArrayLike(Buffer))
            .digest())
            .digest();
        const encryptionKey = hash.slice(0, 32);
        const MACKey = hash.slice(32);
        const computedMAC = this.calculateMAC(MACKey, iv, ephemPubKeyEncoded, ciphertext);
        // Verify MAC
        if (!computedMAC.equals(MAC)) {
            throw new Error('MAC mismatch');
        }
        const plaintext = this.AES256CbcDecrypt(iv, encryptionKey, ciphertext);
        return plaintext;
    }
    static encrypt(pubKeyTo, plaintext) {
        const ephemPrivKey = ec.keyFromPrivate(crypto.randomBytes(32));
        const ephemPubKey = ephemPrivKey.getPublic();
        const ephemPubKeyEncoded = Buffer.from(ephemPubKey.encode('be', true));
        // Every EC public key begins with the 0x04 prefix before giving the location of the two point on the curve
        // const px = ephemPrivKey.derive(ec.keyFromPublic(Buffer.concat([Buffer.from([0x04]), pubKeyTo])).getPublic())
        const px = ephemPrivKey.derive(ec.keyFromPublic(pubKeyTo).getPublic(true));
        // Double hash to preven lenght extension attacks
        const hash = crypto
            .createHash('sha512')
            .update(crypto
            .createHash('sha512')
            .update(px.toArrayLike(Buffer))
            .digest())
            .digest();
        const iv = crypto.randomBytes(16);
        const encryptionKey = hash.slice(0, 32);
        const MACKey = hash.slice(32);
        const ciphertext = this.AES256CbcEncrypt(iv, encryptionKey, plaintext);
        const MAC = this.calculateMAC(MACKey, iv, ephemPubKeyEncoded, ciphertext);
        let offset = 0;
        let serializedCiphertext = new Buffer(iv.length +
            1 +
            ephemPubKeyEncoded.length +
            4 +
            ciphertext.length +
            MAC.length);
        // IV
        iv.copy(serializedCiphertext, 0);
        offset += iv.length;
        // Ephemeral key
        serializedCiphertext.writeUInt8(ephemPubKeyEncoded.length, offset);
        offset++;
        ephemPubKeyEncoded.copy(serializedCiphertext, offset);
        offset += ephemPubKeyEncoded.length;
        // Ciphertext
        serializedCiphertext.writeUInt32BE(ciphertext.length, offset);
        offset += 4;
        ciphertext.copy(serializedCiphertext, offset);
        offset += ciphertext.length;
        // MAC
        MAC.copy(serializedCiphertext, offset);
        return serializedCiphertext;
    }
    static calculateMAC(MACKey, iv, ephemPubKeyEncoded, ciphertext) {
        const dataToMAC = Buffer.concat([iv, ephemPubKeyEncoded, ciphertext]);
        return crypto
            .createHmac('sha256', MACKey)
            .update(dataToMAC)
            .digest();
    }
}
/**
 * AES-256 CBC encrypt
 * @param {Buffer} iv
 * @param {Buffer} key
 * @param {Buffer} plaintext
 * @returns {Buffer} ciphertext
 */
RadixECIES.AES256CbcEncrypt = (iv, key, plaintext) => {
    const cipher = crypto.createCipheriv('aes-256-cbc', key, iv);
    const firstChunk = cipher.update(plaintext);
    const secondChunk = cipher.final();
    return Buffer.concat([firstChunk, secondChunk]);
};
/**
 * AES-256 CBC decrypt
 * @param {Buffer} iv
 * @param {Buffer} key
 * @param {Buffer} ciphertext
 * @returns {Buffer} plaintext
 */
RadixECIES.AES256CbcDecrypt = (iv, key, ciphertext) => {
    const cipher = crypto.createDecipheriv('aes-256-cbc', key, iv);
    const firstChunk = cipher.update(ciphertext);
    const secondChunk = cipher.final();
    return Buffer.concat([firstChunk, secondChunk]);
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmFkaXhFQ0lFUy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9tb2R1bGVzL2NyeXB0by9SYWRpeEVDSUVTLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sWUFBWSxNQUFNLGVBQWUsQ0FBQTtBQUN4QyxPQUFPLEVBQUUsTUFBTSxVQUFVLENBQUE7QUFDekIsT0FBTyxNQUFNLE1BQU0sUUFBUSxDQUFBO0FBRTNCLE1BQU0sRUFBRSxHQUFHLElBQUksRUFBRSxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUMsQ0FBQTtBQUVqQyxNQUFNLENBQUMsT0FBTyxPQUFPLFVBQVU7SUFDM0IsTUFBTSxDQUFDLE9BQU8sQ0FBQyxPQUFlLEVBQUUsU0FBaUI7UUFDN0MsSUFBSSxNQUFNLEdBQUcsSUFBSSxZQUFZLENBQUMsU0FBUyxDQUFDLENBQUE7UUFFeEMsTUFBTSxFQUFFLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsQ0FBQTtRQUNoQyxNQUFNLGtCQUFrQixHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUE7UUFDaEUsTUFBTSxVQUFVLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQTtRQUMzRCxNQUFNLEdBQUcsR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxDQUFBO1FBRWpDLE1BQU0sV0FBVyxHQUFHLEVBQUUsQ0FBQyxhQUFhLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxTQUFTLEVBQUUsQ0FBQTtRQUVwRSxNQUFNLEVBQUUsR0FBRyxFQUFFLENBQUMsY0FBYyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQTtRQUN6RCxrREFBa0Q7UUFDbEQsTUFBTSxJQUFJLEdBQUcsTUFBTTthQUNkLFVBQVUsQ0FBQyxRQUFRLENBQUM7YUFDcEIsTUFBTSxDQUNILE1BQU07YUFDRCxVQUFVLENBQUMsUUFBUSxDQUFDO2FBQ3BCLE1BQU0sQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDO2FBQzlCLE1BQU0sRUFBRSxDQUNoQjthQUNBLE1BQU0sRUFBRSxDQUFBO1FBQ2IsTUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUE7UUFDdkMsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQTtRQUU3QixNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUNqQyxNQUFNLEVBQ04sRUFBRSxFQUNGLGtCQUFrQixFQUNsQixVQUFVLENBQ2IsQ0FBQTtRQUVELGFBQWE7UUFDYixJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUMxQixNQUFNLElBQUksS0FBSyxDQUFDLGNBQWMsQ0FBQyxDQUFBO1NBQ2xDO1FBRUQsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEVBQUUsRUFBRSxhQUFhLEVBQUUsVUFBVSxDQUFDLENBQUE7UUFDdEUsT0FBTyxTQUFTLENBQUE7SUFDcEIsQ0FBQztJQUVELE1BQU0sQ0FBQyxPQUFPLENBQUMsUUFBZ0IsRUFBRSxTQUFpQjtRQUM5QyxNQUFNLFlBQVksR0FBRyxFQUFFLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQTtRQUM5RCxNQUFNLFdBQVcsR0FBRyxZQUFZLENBQUMsU0FBUyxFQUFFLENBQUE7UUFDNUMsTUFBTSxrQkFBa0IsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUE7UUFDdEUsMkdBQTJHO1FBQzNHLCtHQUErRztRQUMvRyxNQUFNLEVBQUUsR0FBRyxZQUFZLENBQUMsTUFBTSxDQUMxQixFQUFFLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FDN0MsQ0FBQTtRQUNELGlEQUFpRDtRQUNqRCxNQUFNLElBQUksR0FBRyxNQUFNO2FBQ2QsVUFBVSxDQUFDLFFBQVEsQ0FBQzthQUNwQixNQUFNLENBQ0gsTUFBTTthQUNELFVBQVUsQ0FBQyxRQUFRLENBQUM7YUFDcEIsTUFBTSxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUM7YUFDOUIsTUFBTSxFQUFFLENBQ2hCO2FBQ0EsTUFBTSxFQUFFLENBQUE7UUFFYixNQUFNLEVBQUUsR0FBRyxNQUFNLENBQUMsV0FBVyxDQUFDLEVBQUUsQ0FBQyxDQUFBO1FBQ2pDLE1BQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFBO1FBQ3ZDLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUE7UUFDN0IsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEVBQUUsRUFBRSxhQUFhLEVBQUUsU0FBUyxDQUFDLENBQUE7UUFDdEUsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FDekIsTUFBTSxFQUNOLEVBQUUsRUFDRixrQkFBa0IsRUFDbEIsVUFBVSxDQUNiLENBQUE7UUFFRCxJQUFJLE1BQU0sR0FBRyxDQUFDLENBQUE7UUFDZCxJQUFJLG9CQUFvQixHQUFHLElBQUksTUFBTSxDQUNqQyxFQUFFLENBQUMsTUFBTTtZQUNMLENBQUM7WUFDRCxrQkFBa0IsQ0FBQyxNQUFNO1lBQ3pCLENBQUM7WUFDRCxVQUFVLENBQUMsTUFBTTtZQUNqQixHQUFHLENBQUMsTUFBTSxDQUNqQixDQUFBO1FBRUQsS0FBSztRQUNMLEVBQUUsQ0FBQyxJQUFJLENBQUMsb0JBQW9CLEVBQUUsQ0FBQyxDQUFDLENBQUE7UUFDaEMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxNQUFNLENBQUE7UUFFbkIsZ0JBQWdCO1FBQ2hCLG9CQUFvQixDQUFDLFVBQVUsQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUE7UUFDbEUsTUFBTSxFQUFFLENBQUE7UUFDUixrQkFBa0IsQ0FBQyxJQUFJLENBQUMsb0JBQW9CLEVBQUUsTUFBTSxDQUFDLENBQUE7UUFDckQsTUFBTSxJQUFJLGtCQUFrQixDQUFDLE1BQU0sQ0FBQTtRQUVuQyxhQUFhO1FBQ2Isb0JBQW9CLENBQUMsYUFBYSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUE7UUFDN0QsTUFBTSxJQUFJLENBQUMsQ0FBQTtRQUNYLFVBQVUsQ0FBQyxJQUFJLENBQUMsb0JBQW9CLEVBQUUsTUFBTSxDQUFDLENBQUE7UUFDN0MsTUFBTSxJQUFJLFVBQVUsQ0FBQyxNQUFNLENBQUE7UUFFM0IsTUFBTTtRQUNOLEdBQUcsQ0FBQyxJQUFJLENBQUMsb0JBQW9CLEVBQUUsTUFBTSxDQUFDLENBQUE7UUFFdEMsT0FBTyxvQkFBb0IsQ0FBQTtJQUMvQixDQUFDO0lBRUQsTUFBTSxDQUFDLFlBQVksQ0FDZixNQUFjLEVBQ2QsRUFBVSxFQUNWLGtCQUEwQixFQUMxQixVQUFrQjtRQUVsQixNQUFNLFNBQVMsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxFQUFFLGtCQUFrQixFQUFFLFVBQVUsQ0FBQyxDQUFDLENBQUE7UUFDckUsT0FBTyxNQUFNO2FBQ1IsVUFBVSxDQUFDLFFBQVEsRUFBRSxNQUFNLENBQUM7YUFDNUIsTUFBTSxDQUFDLFNBQVMsQ0FBQzthQUNqQixNQUFNLEVBQUUsQ0FBQTtJQUNqQixDQUFDOztBQUVEOzs7Ozs7R0FNRztBQUNJLDJCQUFnQixHQUFHLENBQUMsRUFBVSxFQUFFLEdBQVcsRUFBRSxTQUFpQixFQUFFLEVBQUU7SUFDckUsTUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLGNBQWMsQ0FBQyxhQUFhLEVBQUUsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFBO0lBQzVELE1BQU0sVUFBVSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUE7SUFDM0MsTUFBTSxXQUFXLEdBQUcsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFBO0lBQ2xDLE9BQU8sTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLFVBQVUsRUFBRSxXQUFXLENBQUMsQ0FBQyxDQUFBO0FBQ25ELENBQUMsQ0FBQTtBQUVEOzs7Ozs7R0FNRztBQUNJLDJCQUFnQixHQUFHLENBQUMsRUFBVSxFQUFFLEdBQVcsRUFBRSxVQUFrQixFQUFFLEVBQUU7SUFDdEUsTUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLGdCQUFnQixDQUFDLGFBQWEsRUFBRSxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUE7SUFDOUQsTUFBTSxVQUFVLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQTtJQUM1QyxNQUFNLFdBQVcsR0FBRyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUE7SUFDbEMsT0FBTyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsVUFBVSxFQUFFLFdBQVcsQ0FBQyxDQUFDLENBQUE7QUFDbkQsQ0FBQyxDQUFBIn0=